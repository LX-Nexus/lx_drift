{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#welcome-lexi-developer","title":"Welcome Lexi Developer","text":""},{"location":"index.html#lexi-ui-development-guide","title":"Lexi UI Development Guide","text":"<p>This document provides a comprehensive guide for developers working on the Lexi user interface. It aims to clarify the codebase structure, explain the rationale behind key design decisions, particularly the use of Base64 for images and animations, and outline best practices for UI development within the Lexi project.</p>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html","title":"Lexi UI Development Guide (2)","text":""},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#welcome-lexi-developer","title":"Welcome Lexi Developer","text":""},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#lexi-ui-development-guide","title":"Lexi UI Development Guide","text":"<p>This document provides a comprehensive guide for developers working on the Lexi user interface. It aims to clarify the codebase structure, explain the rationale behind key design decisions, particularly the use of Base64 for images and animations, and outline best practices for UI development within the Lexi project.</p>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#1-introduction-to-lexi","title":"1. Introduction to Lexi","text":"<p>Lexi is an intelligent AI assistant built using Python and the Flet framework. It leverages various machine learning models for natural language processing, code generation, and conversational AI. The UI is designed to be responsive and intuitive, providing a seamless user experience across different platforms.</p>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#2-codebase-overview","title":"2. Codebase Overview","text":"<p>The Lexi codebase (<code>Drift_mini.py</code>) is a monolithic application that integrates several powerful libraries and components:</p> <ul> <li>Flet: Used for building the cross-platform user interface. Flet allows developers to create desktop, web, and mobile applications using Python.</li> <li>Hugging Face Transformers: Utilized for loading and managing large language models (LLMs) and sentence transformers for various AI tasks, including text generation and embeddings.</li> <li>Langchain: Provides a framework for developing applications powered by language models, facilitating conversational AI and document processing.</li> <li>Llama.cpp: A C/C++ port of Facebook's LLaMA model, used here for efficient local inference of GGUF models.</li> <li>PyGments: Used for syntax highlighting of code snippets within the UI.</li> <li>PyPDFLoader: For loading and processing PDF documents.</li> </ul> <p>The application structure includes components for model selection, PDF processing, chat interaction, and UI rendering. The core logic resides within the <code>Drift_mini.py</code> file, managing both the backend AI operations and the frontend UI presentation.</p>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#3-ui-architecture-with-flet","title":"3. UI Architecture with Flet","text":"<p>Lexi's user interface is built with Flet, a framework that enables building reactive UIs in Python. Flet applications are composed of controls (widgets) that form a visual tree. Changes to this tree are efficiently rendered to the underlying UI platform (web, desktop, or mobile).</p> <p>Key aspects of Flet's usage in Lexi:</p> <ul> <li>Reactive Programming: The UI responds to state changes. When data changes, the relevant UI components are automatically updated.</li> <li>Controls: Flet provides a rich set of pre-built UI controls (e.g., <code>ft.Text</code>, <code>ft.Image</code>, <code>ft.Container</code>, <code>ft.ProgressBar</code>) that are used to construct the application's layout and interactive elements.</li> <li>Page Updates: UI changes are typically triggered by calling <code>page.update()</code>, which sends the updated control tree to the Flet client for rendering.</li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#4-base64-for-images-and-animations","title":"4. Base64 for Images and Animations","text":"<p>Lexi utilizes Base64 encoding for embedding images and animations directly within the application's source code or configuration files. This approach is specifically evident in how the Lexi avatar (<code>avatar_base64.txt</code>) and application icon (<code>icon_base64.txt</code>) are handled. These files contain Base64 encoded strings of the respective image/GIF data.</p>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#41-why-base64","title":"4.1. Why Base64?","text":"<p>The decision to use Base64 for certain UI assets in Lexi, especially within a Flet application, is driven by several factors, primarily related to deployment, portability, and reduced HTTP requests in web contexts:</p> <ul> <li> <p>Self-Contained Deployment: By embedding images as Base64 strings, the application becomes more self-contained. The image data is part of the Python script or easily accessible text files, eliminating the need for separate image files that might get lost or misplaced during deployment. This simplifies distribution, especially for desktop applications, as all assets are bundled together.</p> </li> <li> <p>Reduced HTTP Requests (Web): In web-based Flet deployments, using Base64 encoded images means the browser doesn't need to make additional HTTP requests to fetch image files. The image data is already present in the HTML/CSS/JavaScript payload. For small, frequently used assets like icons and avatars, this can slightly improve initial load times by reducing network overhead. [1]</p> </li> <li> <p>Portability: Base64 encoded assets are plain text, making them highly portable across different environments and operating systems. They can be easily stored in text files, databases, or directly in code without worrying about binary file compatibility issues.</p> </li> <li> <p>Avoiding File System Access Issues: For applications packaged with tools like PyInstaller (which Lexi appears to be designed for, given the <code>sys._MEIPASS</code> handling), accessing external asset files can sometimes be problematic due to how the executable bundles resources. Embedding assets via Base64 bypasses these potential file path resolution issues at runtime.</p> </li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#42-disadvantages-and-considerations","title":"4.2. Disadvantages and Considerations","text":"<p>While Base64 offers benefits, it also comes with drawbacks that are important for the UI team to understand:</p> <ul> <li> <p>Increased File Size: Base64 encoding increases the size of the original binary data by approximately 33%. [2] This means that <code>avatar_base64.txt</code> and <code>icon_base64.txt</code> are larger than their original image files. For very large images or numerous small images, this overhead can significantly increase the overall application size and memory footprint.</p> </li> <li> <p>Caching Inefficiency: Base64 encoded images are embedded directly into the HTML (or in Flet's case, sent as part of the control tree). This means they cannot be cached independently by the browser like external image files. Every time the page or component loads, the Base64 data is re-downloaded/re-processed, which can be inefficient for frequently accessed or larger assets.</p> </li> <li> <p>Maintenance Overhead: Editing or updating Base64 encoded images requires re-encoding the image and updating the corresponding text file or code. This can be a less straightforward workflow compared to simply replacing an image file.</p> </li> <li> <p>Performance for Animations: For animations (like the Lexi avatar GIF), Base64 encoding means the entire animation data is loaded at once. While convenient for bundling, for longer or more complex animations, this can consume more memory and potentially impact rendering performance compared to streaming or optimized animation formats.</p> </li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#43-implementation-details-in-lexi","title":"4.3. Implementation Details in Lexi","text":"<p>In <code>Drift_mini.py</code>, you'll find code snippets similar to these for handling Base64 assets:</p> <pre><code># For the application icon\ntry:\n    with open(\"assets/icon_base64.txt\", \"r\") as f:\n        icon_base64 = f.read()\nexcept Exception as e:\n    print(\"\u26a0\ufe0f Failed to load base64 image:\", e)\n    icon_base64 = \"\"\n\nimage_control = ft.Image(\n    src=f\"data:image/png;base64,{icon_base64}\",\n    width=1200,\n    height=1200,\n    fit=ft.ImageFit.COVER\n)\n\n# For the Lexi avatar (GIF)\ntry:\n    with open(os.path.join(\n            os.path.dirname(os.path.abspath(__file__)),\n            \"assets\",\n            \"avatar_base64.txt\"\n    )) as f:\n        avatar_b64 = f.read().strip()\nexcept Exception:\n    avatar_b64 = \"\"   # fallback: blank avatar\n\navatar = ft.Container(\n    content=ft.Image(\n        src=f\"data:image/gif;base64,{avatar_b64}\",\n        width=40,\n        height=40,\n        fit=ft.ImageFit.COVER,\n        repeat=ft.ImageRepeat.NO_REPEAT,\n    ),\n)\n</code></pre> <p>As you can see, the Base64 string is read from a <code>.txt</code> file and then directly embedded into the <code>src</code> property of an <code>ft.Image</code> control using a <code>data:</code> URI scheme (<code>data:image/png;base64,...</code> or <code>data:image/gif;base64,...</code>).</p>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#5-ui-development-guidelines","title":"5. UI Development Guidelines","text":"<p>When contributing to Lexi's UI, please adhere to the following guidelines:</p>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#51-understanding-flet-controls-and-layout","title":"5.1. Understanding Flet Controls and Layout","text":"<ul> <li>Familiarize yourself with Flet documentation: Before making significant UI changes, review the official Flet documentation to understand available controls, their properties, and layout options.</li> <li>Use appropriate controls: Select Flet controls that best fit the UI element's purpose and interaction. For example, <code>ft.Container</code> for grouping and styling, <code>ft.Text</code> for static text, <code>ft.TextField</code> for input.</li> <li>Responsive Design: Design UI components to be responsive. Flet's layout system (e.g., <code>Row</code>, <code>Column</code>, <code>Container</code> with <code>expand</code> property, <code>ResponsiveRow</code>) should be used to ensure the UI adapts gracefully to different screen sizes and orientations.</li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#52-working-with-images-and-animations","title":"5.2. Working with Images and Animations","text":"<ul> <li>Existing Base64 Assets: For the Lexi icon and avatar, continue to use the existing Base64 approach. If these assets need to be updated, convert the new image/GIF to Base64 and replace the content of <code>icon_base64.txt</code> or <code>avatar_base64.txt</code> respectively. You can use online tools or command-line utilities (e.g., <code>base64 -i image.png &gt; image_base64.txt</code>) for conversion.</li> <li>New Static Images: For any new static images that are small and integral to the application's self-contained nature (e.g., small icons, logos that are always displayed), consider converting them to Base64 and embedding them similarly. However, be mindful of the file size overhead.</li> <li>Larger Images/Dynamic Content: For larger images, user-uploaded content, or images that might change frequently, consider alternative approaches that Flet supports, such as loading images from local paths or URLs. Flet's <code>ft.Image</code> control can directly take a file path or a URL as its <code>src</code> property. This avoids the Base64 overhead for assets that don't benefit from it.</li> <li>Animations: For complex or longer animations, evaluate if GIF is the most suitable format. While Base64 embedded GIFs work for simple animations, consider optimized video formats or Lottie animations if Flet supports them in the future, especially if performance becomes an issue.</li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#53-styling-and-theming","title":"5.3. Styling and Theming","text":"<ul> <li>Consistent Styling: Maintain a consistent visual style throughout the application. Use Flet's theming capabilities (if available and implemented) or consistently apply <code>ft.TextStyle</code> and <code>ft.Container</code> properties for colors, fonts, padding, and margins.</li> <li>Color Palette: Adhere to Lexi's defined color palette. If no formal palette exists, establish one and document it.</li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#54-code-quality-and-maintainability","title":"5.4. Code Quality and Maintainability","text":"<ul> <li>Modularity: Break down complex UI into smaller, reusable Flet controls or functions. This improves readability and maintainability.</li> <li>Clear Naming Conventions: Use descriptive names for variables, functions, and controls.</li> <li>Comments: Add comments where necessary to explain complex logic or non-obvious UI decisions.</li> <li>Error Handling: Implement robust error handling for UI operations, especially when dealing with external resources or user input.</li> <li>Performance: Be mindful of UI performance. Avoid unnecessary <code>page.update()</code> calls and optimize complex layouts.</li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#6-contribution-workflow","title":"6. Contribution Workflow","text":"<ol> <li>Branching: Create a new branch for your UI changes (e.g., <code>feature/new-chat-ui</code>, <code>fix/avatar-display</code>).</li> <li>Development: Implement your UI changes, following the guidelines above.</li> <li>Testing: Thoroughly test your changes across different screen sizes and interactions.</li> <li>Code Review: Submit a pull request for review by another team member.</li> <li>Deployment: Once approved, merge your changes to the main branch.</li> </ol>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#7-resources","title":"7. Resources","text":"<ul> <li>Flet Documentation</li> <li>Flet GitHub Repository</li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#8-detailed-ui-elements-and-functionality","title":"8. Detailed UI Elements and Functionality","text":"<p>Lexi's user interface is designed to be intuitive and functional, guiding the user through model interaction, PDF processing, and conversational AI. This section details the key UI components, their purpose, and relevant code snippets.</p>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#81-initial-loading-and-download-screen","title":"8.1. Initial Loading and Download Screen","text":"<p>Upon launching Lexi, the application first checks for and downloads necessary AI models. This process is represented by a dynamic loading screen, ensuring the user is aware of the background operations.</p> <p>Purpose: To provide visual feedback during the initial setup, model download, and loading phases, preventing the application from appearing unresponsive. It also informs the user about the progress of large file downloads.</p> <p>Key Components &amp; Functionality:</p> <ul> <li> <p>Progress Bar (<code>ft.ProgressBar</code>): Displays the overall download and loading progress. The <code>HfProgress</code> class customizes this to show Hugging Face model download progress.     <pre><code># Snippet from HfProgress class in Drift_mini.py\nclass HfProgress(tqdm):\n    # ... (init and other methods)\n    def display(self, msg=None, pos=None):\n        # Calculate percentage\n        if self.total and self.n is not None and self.total &gt; 0:\n            percentage = 100.0 * self.n / self.total\n        else:\n            percentage = 0.0\n\n        # Construct status message\n        if self.n is not None and self.total is not None:\n            status_msg = f\"Downloading: {self.n / 1024 / 1024:.1f}MB / {self.total / 1024 / 1024:.1f}MB ({percentage:.1f}%)\"\n        else:\n            status_msg = \"Downloading: calculating size...\"\n\n        # Update UI\n        if hasattr(self, 'screen') and self.screen and not self.screen.is_cancelled and self.screen.active:\n            try:\n                self.screen.update_progress(\n                    40 + (percentage * 0.6),  # Scale to 40-100% range (embedding is first 40%)\n                    status_msg\n                )\n            except Exception as e:\n                print(f\"Error updating progress UI: {e}\")\n        # ...\n</code></pre></p> </li> <li> <p>Status Text (<code>ft.Text</code>): Provides textual updates on the current operation (e.g., \"Initializing...\", \"Downloading models...\", \"Loading LLM...\").     <pre><code>    # Snippet from main function in Drift_mini.py\n    status_text = ft.Text(\"Initializing...\", size=16, color=\"white\")\n    # ...\n    page.add(ft.Container(\n        content=ft.Column([\n            ft.Image(\n                src=f\"data:image/png;base64,{icon_base64}\",\n                width=1200,\n                height=1200,\n                fit=ft.ImageFit.COVER\n            ),\n            ft.Container(height=16),\n            status_text,\n            ft.Container(height=16),\n            progress_bar\n        ]),\n        alignment=ft.alignment.center,\n        expand=True\n    ))\n</code></pre></p> </li> <li> <p>Error Messages: If model download or initialization fails, a clear error message is displayed to the user.         <pre><code># Snippet from main function in Drift_mini.py\nif not success:\n    page.add(ft.Container(\n        content=ft.Text(\"\u274c Model download failed. Please check your connection.\", color=\"white\"),\n        alignment=ft.alignment.center,\n        expand=True\n    ))\n    page.update()\n    return\n# ...\nif not success:\n    page.add(ft.Container(\n        content=ft.Text(\"\u274c Failed to initialize. Check models or logs.\", color=\"white\"),\n        alignment=ft.alignment.center,\n        expand=True\n    ))\n    page.update()\n    return\n</code></pre></p> </li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#82-main-chat-interface","title":"8.2. Main Chat Interface","text":"<p>Once initialized, the user is presented with the main chat interface, which facilitates interaction with the Lexi AI.</p> <p>Key Components &amp; Functionality:</p> <ul> <li> <p>App Bar (<code>ft.AppBar</code> or <code>ft.Container</code> acting as one): Located at the top, it contains the application title, status indicators, and action buttons.</p> <ul> <li>Lexi Icon and Title: Displays the Lexi logo (Base64 encoded) and the application name.</li> <li>Model Status Indicator (<code>ft.Text</code>): Shows which model is currently loaded (e.g., \"Optimal Model Selected\").</li> <li>Model Selection Button (<code>ft.IconButton</code>): Triggers a dialog for the user to select a different AI model.     <pre><code># Snippet from app_bar creation in Drift_mini.py\napp_bar = ft.Container(\n    content=ft.Row([\n        ft.IconButton(\n            icon=ft.icons.MENU,\n            icon_color=\"#FFFFFF\",\n            on_click=lambda e: page.go(\"/settings\"), # Example navigation\n        ),\n        ft.Container(width=12),\n        ft.Column([\n            ft.Text(\n                \"Lexi Drift\",\n                color=\"#FFFFFF\",\n                size=20,\n                weight=ft.FontWeight.BOLD,\n            ),\n            ft.Text(\n                \"Optimal Model Selected\", # This text changes based on model status\n                color=\"#BDBDBD\",\n                size=12,\n            ),\n        ]),\n        ft.Container(expand=True), \n        ft.TextButton(\n            content=ft.Row([\n                ft.Icon(ft.icons.SETTINGS, color=\"#FFFFFF\"),\n                ft.Text(\"Models\", color=\"#FFFFFF\"),\n            ]),\n            on_click=lambda e: open_model_dialog(),\n        ),\n        ft.IconButton(\n            icon=ft.icons.INFO_OUTLINE,\n            icon_color=\"#FFFFFF\",\n            on_click=lambda e: open_info_dialog(),\n        ),\n        ft.IconButton(\n            icon=ft.icons.FILE_UPLOAD,\n            icon_color=\"#FFFFFF\",\n            on_click=lambda e: file_picker.pick_files(allow_multiple=True),\n        ),\n    ]),\n    padding=ft.padding.only(left=10, right=10, top=5, bottom=5),\n    bgcolor=\"#202020\",\n    width=page.width,\n)\n</code></pre></li> <li>Info Button (<code>ft.IconButton</code>): Displays information about the application or current model.</li> <li>File Upload Button (<code>ft.IconButton</code>): Initiates the file picker to allow users to upload documents (e.g., PDFs) for processing.     <pre><code># Snippet from file picker setup in Drift_mini.py\nfile_picker = ft.FilePicker(\n    on_result=lambda e: on_file_picked(e, page, chat_column, input_field, send_button, typing_indicator, info_card)\n)\npage.overlay.append(file_picker)\n</code></pre></li> </ul> </li> <li> <p>Chat History Area (<code>ft.Column</code>): This is the main display area where conversational turns (user queries and Lexi's responses) are rendered.</p> <ul> <li>User Messages: Displayed with a distinct background and alignment (e.g., right-aligned).</li> <li>Lexi Messages: Displayed with a distinct background and alignment (e.g., left-aligned), often accompanied by the Lexi avatar.</li> <li>Code Highlighting: Lexi can generate code, which is then highlighted using Pygments for readability.     <pre><code># Snippet from message rendering in Drift_mini.py\n# ... inside a function that adds messages to chat_column\nif is_user:\n    bubble = ft.Container(\n        content=ft.Text(message, color=\"#FFFFFF\"),\n        bgcolor=\"#4A4A4A\",\n        border_radius=10,\n        padding=10,\n    )\n    msg_widget = ft.Row([ft.Container(expand=True), bubble], alignment=ft.MainAxisAlignment.END)\nelse:\n    # ... Lexi avatar logic ...\n    if message.startswith(\"```\") and message.endswith(\"```\"):\n        # Code block, apply highlighting\n        lang_match = re.match(r\"```(\\w+)?\\n\", message)\n        lang = lang_match.group(1) if lang_match else \"text\"\n        code_content = message[lang_match.end():-3].strip()\n        highlighted_spans = highlight_code_multilang(code_content, lang)\n        bubble_content = ft.Column([\n            ft.Text(\"Lexi:\", color=\"#FFFFFF\", weight=ft.FontWeight.BOLD),\n            ft.Container(height=5),\n            ft.Column(highlighted_spans, spacing=0)\n        ])\n    else:\n        bubble_content = ft.Text(message, color=\"#FFFFFF\")\n\n    bubble = ft.Container(\n        content=bubble_content,\n        bgcolor=\"#333333\",\n        border_radius=10,\n        padding=10,\n    )\n    msg_widget = ft.Row([avatar, bubble], alignment=ft.MainAxisAlignment.START)\nchat_column.controls.append(msg_widget)\npage.update()\n</code></pre></li> </ul> </li> <li> <p>Typing Indicator (<code>ft.Container</code> with <code>ft.Text</code>): Appears when Lexi is generating a response, providing visual cues that the AI is processing.     <pre><code># Snippet from typing indicator in Drift_mini.py\ntyping_indicator = ft.Container(\n    content=ft.Row([\n        ft.ProgressRing(width=16, height=16, stroke_width=2),\n        ft.Text(\"Lexi is typing...\", color=\"#BDBDBD\"),\n    ]),\n    visible=False, # Initially hidden\n)\n</code></pre></p> </li> <li> <p>PDF Processing Indicator: When a PDF is uploaded and processed, a message indicates the status (e.g., \"Processing PDF...\").</p> </li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#83-input-area","title":"8.3. Input Area","text":"<p>At the bottom of the main chat interface, the input area allows users to type their queries and send them to Lexi.</p> <p>Key Components &amp; Functionality:</p> <ul> <li> <p>Text Input Field (<code>ft.TextField</code>): Where the user types their message. It supports multiline input and has a hint text.     <pre><code># Snippet from input_field creation in Drift_mini.py\ninput_field = ft.TextField(\n    hint_text=\"Type your message...\",\n    hint_style=ft.TextStyle(color=\"#BDBDBD\"),\n    multiline=True,\n    min_lines=1,\n    max_lines=5,\n    expand=True,\n    border_radius=15,\n    filled=True,\n    bgcolor=\"#333333\",\n    border_color=\"#4A4A4A\",\n    text_style=ft.TextStyle(color=\"#FFFFFF\"),\n    on_submit=lambda e: send_message(e, page, chat_column, input_field, send_button, typing_indicator, info_card),\n)\n</code></pre></p> </li> <li> <p>Send Button (<code>ft.IconButton</code>): Sends the message typed in the input field to Lexi. It is typically enabled when there is text in the input field.     <pre><code># Snippet from send_button creation in Drift_mini.py\nsend_button = ft.IconButton(\n    icon=ft.icons.SEND,\n    icon_color=\"#FFFFFF\",\n    on_click=lambda e: send_message(e, page, chat_column, input_field, send_button, typing_indicator, info_card),\n    disabled=True, # Initially disabled\n)\n</code></pre></p> </li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#84-model-selection-dialog","title":"8.4. Model Selection Dialog","text":"<p>This dialog allows users to switch between different AI models available in Lexi. It's typically triggered by a button in the app bar.</p> <p>Key Components &amp; Functionality:</p> <ul> <li>Dialog (<code>ft.AlertDialog</code>): A modal overlay that presents model options.</li> <li>Model List (<code>ft.Column</code> of <code>ft.Row</code>s): Each row represents a model, showing its name, description, and a button to select it.     <pre><code># Snippet from open_model_dialog function in Drift_mini.py\ndef open_model_dialog():\n    model_options = [\n        (\"Lexi Lite\", \"Smaller, faster model for quick responses.\", \"phi-1_5-gguf-4bit\"),\n        (\"Lexi Core\", \"Balanced model for general tasks.\", \"phi-2-gguf-4bit\"),\n        (\"Lexi Edge\", \"Advanced model for complex queries.\", \"phi-3-mini-4k-instruct\"),\n        (\"Lexi Ultra\", \"Largest model for maximum capability.\", \"deepseek-llm-7b-chat-gguf-q4\")\n    ]\n\n    model_controls = []\n    for name, description, model_folder in model_options:\n        model_controls.append(\n            ft.Row([\n                ft.Column([\n                    ft.Text(name, weight=ft.FontWeight.W_500, size=14),\n                    ft.Text(description, size=12, color=\"#BDBDBD\"),\n                ]),\n                ft.Container(expand=True),\n                ft.TextButton(\n                    \"Select\",\n                    on_click=partial(select_model, model_folder, name),\n                ),\n            ])\n        )\n\n    dialog = ft.AlertDialog(\n        modal=True,\n        title=ft.Text(\"Available Models\"),\n        content=ft.Column(\n            model_controls,\n            scroll=\"always\",\n            height=300,\n        ),\n        actions=[\n            ft.TextButton(\"Close\", on_click=lambda _: close_dialog()),\n        ],\n        actions_alignment=ft.MainAxisAlignment.END,\n    )\n    page.dialog = dialog\n    dialog.open = True\n    page.update()\n</code></pre></li> <li>Disclaimer: Warns users about potential crashes when switching models.</li> <li>Close Button: Closes the dialog.</li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#85-information-dialog","title":"8.5. Information Dialog","text":"<p>This dialog provides general information about Lexi, potentially including version details, credits, or links to documentation.</p> <p>Key Components &amp; Functionality:</p> <ul> <li>Dialog (<code>ft.AlertDialog</code>): A modal overlay for displaying information.</li> <li>Content (<code>ft.Text</code>): Displays the informational text.</li> <li>Close Button: Closes the dialog.</li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#86-pdf-upload-and-processing","title":"8.6. PDF Upload and Processing","text":"<p>Lexi allows users to upload PDF documents, which are then processed to extract text and create embeddings for conversational context.</p> <p>Key Components &amp; Functionality:</p> <ul> <li>File Picker (<code>ft.FilePicker</code>): A non-visual control that interacts with the operating system to allow users to select files. Its <code>on_result</code> event handler processes the selected files.     <pre><code># Snippet from on_file_picked function in Drift_mini.py\nasync def on_file_picked(e: ft.FilePickerResultEvent, page, chat_column, input_field, send_button, typing_indicator, info_card):\n    if e.files:\n        for file in e.files:\n            # Display message that PDF is being processed\n            add_message(page, chat_column, f\"Processing PDF: {file.name}...\", is_user=True)\n            page.update()\n\n            # Simulate processing time or actual processing\n            await asyncio.sleep(1) \n\n            # Actual PDF processing logic (simplified for snippet)\n            pdf_path = file.path\n            if pdf_path:\n                # ... (PDF loading, splitting, embedding logic)\n                add_message(page, chat_column, f\"PDF '{file.name}' processed and ready for questions!\", is_user=False)\n            else:\n                add_message(page, chat_column, f\"Failed to load PDF '{file.name}'.\", is_user=False)\n            page.update()\n</code></pre></li> <li>Status Messages in Chat: Messages are added to the chat history to inform the user about the PDF processing status (e.g., \"Processing PDF: ...\", \"PDF processed...\").</li> </ul> <p>This detailed breakdown should provide your team with a clear understanding of Lexi's UI components, their purpose, and how they are implemented within the <code>Drift_mini.py</code> codebase. When making changes or adding new features, always consider the existing structure and design principles.</p>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#9-data-handling-and-lexi_driftpdf","title":"9. Data Handling and <code>lexi_drift.pdf</code>","text":"<p>Lexi leverages various data sources to provide comprehensive and contextually relevant responses. A crucial component of this data handling is the <code>lexi_drift.pdf</code> file.</p>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#91-purpose-of-lexi_driftpdf","title":"9.1. Purpose of <code>lexi_drift.pdf</code>","text":"<p><code>lexi_drift.pdf</code> serves as a foundational knowledge base for Lexi, particularly for generating initial greetings and general conversational responses. When the application launches, this PDF is automatically loaded and its content is used to prime Lexi's understanding. This allows Lexi to provide consistent and pre-defined responses to common scenarios or initial user interactions without relying solely on its large language model for every basic query.</p> <p>Key Roles:</p> <ul> <li>Default Greetings and General Responses: It contains pre-authored text that guides Lexi's initial interactions, ensuring a friendly and consistent user experience from the start.</li> <li>Scenario-Based Interactions: The design allows for the inclusion of responses to specific, pre-defined scenarios. By adding relevant information or conversational flows into <code>lexi_drift.pdf</code>, Lexi can provide tailored and accurate answers for particular situations, acting as a form of 'programmed' knowledge.</li> </ul>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#92-how-lexi_driftpdf-is-used","title":"9.2. How <code>lexi_drift.pdf</code> is Used","text":"<p>When Lexi starts, the <code>Drift_mini.py</code> script identifies and processes <code>lexi_drift.pdf</code>. The content of this PDF is then converted into a format that the AI model can utilize for retrieval-augmented generation. This typically involves:</p> <ol> <li>Loading: The <code>PyPDFLoader</code> (from <code>langchain_community.document_loaders</code>) is used to read the text content from <code>lexi_drift.pdf</code>.</li> <li>Text Splitting: The extracted text is broken down into smaller, manageable chunks using a <code>RecursiveCharacterTextSplitter</code>. This is crucial for efficient processing and retrieval by the language model.</li> <li>Embedding: Each text chunk is then converted into numerical vector representations (embeddings) using a <code>SentenceTransformer</code> model (e.g., <code>all-MiniLM-L6-v2</code>). These embeddings capture the semantic meaning of the text.</li> <li>Vector Store: The embeddings are stored in a <code>Chroma</code> vector database. This database allows for fast and efficient similarity searches, enabling Lexi to quickly find relevant information from the PDF based on user queries.</li> <li>Conversational Retrieval Chain: A <code>ConversationalRetrievalChain</code> (from <code>langchain.chains</code>) is established. This chain uses the vector store to retrieve relevant document chunks from <code>lexi_drift.pdf</code> based on the current conversation history and user input. The retrieved information is then provided to the main language model as context, allowing it to generate more informed and accurate responses.</li> </ol> <p>Code Snippet for PDF Processing (Conceptual Flow):</p> <pre><code># Snippet from main function or a dedicated PDF processing function in Drift_mini.py\n# ... (imports and setup)\n\nTEMP_PDF = \"./lexi_drift\" # This likely refers to the directory where the PDF is expected or processed\n\nasync def process_pdf_for_rag(pdf_path: str, embeddings_model, vector_store_instance):\n    try:\n        loader = PyPDFLoader(pdf_path)\n        documents = loader.load()\n\n        text_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=1000,\n            chunk_overlap=200\n        )\n        texts = text_splitter.split_documents(documents)\n\n        # Create or update vector store with PDF content\n        # This is a simplified representation; actual implementation might differ\n        vector_store_instance = Chroma.from_documents(texts, embeddings_model)\n\n        print(f\"Successfully processed PDF: {pdf_path}\")\n        return vector_store_instance\n\n    except Exception as e:\n        print(f\"Error processing PDF {pdf_path}: {e}\")\n        return None\n\n# ... (later in main or initialization logic)\n# Assuming 'embeddings' is an initialized HuggingFaceEmbeddings instance\n# and 'vector_db' is a global or passed Chroma instance\n# await process_pdf_for_rag(os.path.join(TEMP_PDF, \"lexi_drift.pdf\"), embeddings, vector_db)\n</code></pre>"},{"location":"Lexi%20UI%20Development%20Guide%20%282%29.html#93-maintaining-and-extending-lexi_driftpdf","title":"9.3. Maintaining and Extending <code>lexi_drift.pdf</code>","text":"<p>For the UI team, understanding <code>lexi_drift.pdf</code> is important for several reasons:</p> <ul> <li>Content Updates: If Lexi's default greetings or responses to specific scenarios need to be updated, the <code>lexi_drift.pdf</code> file is the primary place to make these changes. After updating the PDF, it must be re-processed by the application to reflect the new knowledge.</li> <li>Scenario Expansion: To enable Lexi to handle new, pre-defined conversational scenarios, relevant information can be added to <code>lexi_drift.pdf</code>. This allows for a controlled expansion of Lexi's knowledge base for specific use cases without requiring a full model retraining.</li> <li>Debugging and Testing: When Lexi provides unexpected or incorrect general responses, checking the content of <code>lexi_drift.pdf</code> should be one of the first debugging steps. Ensuring the PDF contains accurate and well-structured information is key to Lexi's performance in these areas.</li> </ul> <p>It is recommended to maintain <code>lexi_drift.pdf</code> with clear, concise, and well-organized text to maximize its effectiveness in guiding Lexi's responses. Avoid overly complex formatting within the PDF, as the primary goal is text extraction for semantic understanding.</p>"},{"location":"guide_split/index.html","title":"Index","text":""},{"location":"guide_split/index.html#welcome-lexi-developer","title":"Welcome Lexi Developer","text":""},{"location":"guide_split/index.html#lexi-ui-development-guide","title":"Lexi UI Development Guide","text":"<p>This document provides a comprehensive guide for developers working on the Lexi user interface. It aims to clarify the codebase structure, explain the rationale behind key design decisions, particularly the use of Base64 for images and animations, and outline best practices for UI development within the Lexi project.</p>"},{"location":"guide_split/10_Database_Implementation_with_SQLite3.html","title":"10. Database Implementation with SQLite3","text":"<p>Lexi will incorporate two SQLite3 databases to manage user-specific data and application usage metrics. SQLite3 is an embedded, serverless, zero-configuration, transactional SQL database engine, making it an ideal choice for local data storage within applications like Lexi. Its simplicity and file-based nature ensure easy deployment and portability, as the entire database is contained within a single file.</p>"},{"location":"guide_split/10_Database_Implementation_with_SQLite3.html#101-overview-of-sqlite3-in-lexi","title":"10.1. Overview of SQLite3 in Lexi","text":"<p>SQLite3 databases will be stored directly alongside the Lexi application, providing a robust yet lightweight solution for persistent data storage. This approach eliminates the need for a separate database server, simplifying the application's architecture and reducing operational overhead. The two distinct databases will serve specific purposes:</p> <p>1.User Email Database: This database will securely store user email addresses, primarily for authentication, communication, or personalized features within Lexi. It will ensure that user contact information is managed efficiently and locally.</p> <p>2.Usage Data Database: This database will collect specific usage data from Lexi when the application is used offline. This data is crucial for understanding user interaction patterns, identifying popular features, and improving the overall user experience. Once an internet connection is available, this usage information will be automatically uploaded to an admin dashboard for centralized viewing and analysis.</p>"},{"location":"guide_split/10_Database_Implementation_with_SQLite3.html#102-core-concepts-for-sqlite3-implementation","title":"10.2. Core Concepts for SQLite3 Implementation","text":"<p>Implementing SQLite3 in Python is straightforward, primarily utilizing the built-in sqlite3 module. The fundamental steps involve connecting to a database, creating tables, inserting data, querying data, and closing the connection. For Lexi, these operations will need to be integrated carefully to ensure data integrity and application responsiveness.</p> <p>Connecting to a Database:</p> <p>To interact with an SQLite3 database, you first need to establish a connection. If the specified database file does not exist, SQLite3 will automatically create it. This connection object is your gateway to performing database operations.</p> <pre><code>import sqlite3\n\ndef get_db_connection(db_name):\n    conn = sqlite3.connect(db_name)\n    conn.row_factory = sqlite3.Row  # This allows accessing columns by name\n    return conn\n</code></pre> <p>Creating Tables:</p> <p>Once connected, you can create tables to define the structure of your data. It's good practice to check if a table already exists before attempting to create it, using CREATE TABLE IF NOT EXISTS.</p> <p><pre><code>def create_tables(conn):\n    cursor = conn.cursor()\n    # Table for user emails\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            email TEXT NOT NULL UNIQUE,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n    ''')\n    # Table for offline usage data\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS usage_data (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_id INTEGER,\n            feature_used TEXT NOT NULL,\n            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n            data_payload TEXT, # e.g., JSON string of specific usage details\n            uploaded BOOLEAN DEFAULT 0, # 0 for not uploaded, 1 for uploaded\n            FOREIGN KEY (user_id) REFERENCES users(id)\n        )\n    ''')\n    conn.commit()\n</code></pre> Inserting Data:</p> <p>Data can be inserted into tables using SQL INSERT statements. It's crucial to use parameterized queries (e.g., ? placeholders) to prevent SQL injection vulnerabilities.</p> <pre><code>def insert_user_email(conn, email):\n    cursor = conn.cursor()\n    try:\n        cursor.execute(\"INSERT INTO users (email) VALUES (?)\n\n\n, (email))\n\n\n, (email))\"\n        cursor.execute(\"INSERT INTO users (email) VALUES (?)\", (email,))\n        conn.commit()\n        return cursor.lastrowid\n    except sqlite3.IntegrityError:\n        print(f\"Email {email} already exists.\")\n        return None\n\ndef insert_usage_data(conn, user_id, feature_used, data_payload=None):\n    cursor = conn.cursor()\n    cursor.execute(\n        \"INSERT INTO usage_data (user_id, feature_used, data_payload) VALUES (?, ?, ?)\",\n        (user_id, feature_used, data_payload)\n    )\n    conn.commit()\n    return cursor.lastrowid\n</code></pre> <p>Querying Data:</p> <p>Retrieving data is done using SELECT statements. The conn.row_factory = sqlite3.Row setting is particularly useful as it allows accessing columns by name, similar to a dictionary.</p> <p><pre><code>def get_user_by_email(conn, email):\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT * FROM users WHERE email = ?\", (email,))\n    return cursor.fetchone()\n\ndef get_unuploaded_usage_data(conn):\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT * FROM usage_data WHERE uploaded = 0\")\n    return cursor.fetchall()\n</code></pre> Updating Data:</p> <p>To mark usage data as uploaded, an UPDATE statement can be used.</p> <pre><code>def mark_usage_data_uploaded(conn, data_ids):\n    cursor = conn.cursor()\n    # Using a placeholder for each ID to prevent SQL injection\n    placeholders = \", \".join([\"?\" for _ in data_ids])\n    cursor.execute(f\"UPDATE usage_data SET uploaded = 1 WHERE id IN ({placeholders})\", data_ids)\n    conn.commit()\n</code></pre>"},{"location":"guide_split/10_Database_Implementation_with_SQLite3.html#103-integration-points-in-drift_minipy","title":"10.3.  Integration Points in Drift_mini.py","text":"<p>Given the current structure of Drift_mini.py, the database functionalities will need to be integrated at several key points. The goal is to ensure that database operations are performed efficiently and without disrupting the existing UI and AI logic.</p>"},{"location":"guide_split/10_Database_Implementation_with_SQLite3.html#1-application-initialization-main-function","title":"1. Application Initialization (main function)**:","text":"<p>Upon application startup, the database connections should be established, and tables should be created if they don't already exist. This ensures that the database is ready for use as soon as Lexi launches.</p> <p>\u2022Proposed Location: Within the main function, early in the execution flow, perhaps after the initial Flet page setup and before model loading.</p> <p>\u2022Example Integration:</p>"},{"location":"guide_split/10_Database_Implementation_with_SQLite3.html#2-user-email-collection-eg-during-first-time-setup-or-registration","title":"2. User Email Collection (e.g., during first-time setup or registration):","text":"<p>If Lexi introduces a feature requiring user email input (e.g., for newsletters, account creation, or personalized settings), this is where the insert_user_email function would be called.</p> <p>\u2022Proposed Location: Within a new Flet dialog or form that prompts the user for their email address. This would likely be triggered by a button click or as part of an onboarding flow.</p> <p>\u2022Example Integration (Conceptual):</p>"},{"location":"guide_split/10_Database_Implementation_with_SQLite3.html#3-usage-data-logging-various-interaction-points","title":"3. Usage Data Logging (various interaction points):","text":"<p>Every significant user interaction or feature usage within Lexi should trigger a call to log data into the usage_data.db. This includes, but is not limited to:</p> <p>\u2022Chat interactions: Each time a user sends a message or receives a response.</p> <p>\u2022PDF processing: When a PDF is loaded, processed, or summarized.</p> <p>\u2022Model changes: When the user switches between different AI models.</p> <p>\u2022Tool usage: If Lexi integrates external tools or functionalities.</p> <p>\u2022Proposed Location: Within the respective event handlers or functions that manage these interactions. For instance, in the send_message function for chat, or within the PDF loading logic.</p> <p>\u2022Example Integration (Conceptual for chat):</p>"},{"location":"guide_split/10_Database_Implementation_with_SQLite3.html#4-data-upload-mechanism-background-task-or-on-app-close","title":"4. Data Upload Mechanism (background task or on app close):","text":"<p>A mechanism is needed to periodically check for unuploaded usage data and send it to the admin dashboard. This could be a background thread that runs at intervals or a process that triggers when the application is closed or an internet connection is detected.</p> <p>\u2022Proposed Location: A separate asynchronous function that can be called periodically (e.g., using asyncio.sleep within a loop) or triggered by network status changes. It should also be considered for execution during graceful application shutdown.</p> <p>\u2022Example Integration (Conceptual):</p>"},{"location":"guide_split/11_Considerations_for_the_Database_Developer.html","title":"11.  Considerations for the Database Developer","text":"<p>\u2022Database File Location: The databases (<code>user_emails.db and usage_data.db</code>) will reside in a lexi_db directory within the application's root. Ensure your implementation correctly references these paths.</p> <p>\u2022Error Handling: Implement robust error handling for all database operations (e.g., try-except blocks for sqlite3.Error). This is crucial for maintaining application stability, especially when dealing with file I/O and potential database corruption.</p> <p>\u2022Concurrency: SQLite3 handles concurrency well for most typical application usage. However, if multiple parts of Lexi attempt to write to the same database simultaneously, consider using locking mechanisms or ensuring that database operations are sequential to prevent sqlite3.OperationalError: database is locked errors. For read operations, multiple concurrent readers are fine.</p> <p>\u2022Data Integrity: Define appropriate NOT NULL and UNIQUE constraints in your CREATE TABLE statements to ensure data quality. For example, email TEXT NOT NULL UNIQUE ensures that no two users have the same email address.</p> <p>\u2022Schema Migrations: As Lexi evolves, the database schema might need to change. Plan for future schema migrations using tools or custom scripts to alter tables without losing existing data. For initial development, simple DROP TABLE IF EXISTS followed by CREATE TABLE might suffice during testing, but this is not suitable for production.</p> <p>\u2022Security: While SQLite3 is local, be mindful of sensitive data. User emails should be handled with care. For the admin dashboard upload, ensure the communication channel is secure (HTTPS) and consider authentication/authorization for the upload endpoint.</p> <p>\u2022Testing: Thoroughly test all database interactions, including edge cases like empty databases, large datasets, and concurrent access scenarios.</p>"},{"location":"guide_split/1_introduction_to_lexi.html","title":"1. Introduction to Lexi","text":""},{"location":"guide_split/1_introduction_to_lexi.html#welcome-lexi-developer","title":"Welcome Lexi Developer","text":""},{"location":"guide_split/1_introduction_to_lexi.html#1-introduction-to-lexi","title":"1. Introduction to Lexi","text":"<p>Lexi is an intelligent AI assistant built using Python and the Flet framework. It leverages various machine learning models for natural language processing, code generation, and conversational AI. The UI is designed to be responsive and intuitive, providing a seamless user experience across different platforms.</p>"},{"location":"guide_split/2_codebase_overview.html","title":"2. Codebase Overview","text":"<p>The Lexi codebase (<code>Drift_mini.py</code>) is a monolithic application that integrates several powerful libraries and components:</p> <ul> <li>Flet: Used for building the cross-platform user interface. Flet allows developers to create desktop, web, and mobile applications using Python.</li> <li>Hugging Face Transformers: Utilized for loading and managing large language models (LLMs) and sentence transformers for various AI tasks, including text generation and embeddings.</li> <li>Langchain: Provides a framework for developing applications powered by language models, facilitating conversational AI and document processing.</li> <li>Llama.cpp: A C/C++ port of Facebook's LLaMA model, used here for efficient local inference of GGUF models.</li> <li>PyGments: Used for syntax highlighting of code snippets within the UI.</li> <li>PyPDFLoader: For loading and processing PDF documents.</li> </ul> <p>The application structure includes components for model selection, PDF processing, chat interaction, and UI rendering. The core logic resides within the <code>Drift_mini.py</code> file, managing both the backend AI operations and the frontend UI presentation.</p>"},{"location":"guide_split/3_ui_architecture_with_flet.html","title":"3. UI Architecture with Flet","text":"<p>Lexi's user interface is built with Flet, a framework that enables building reactive UIs in Python. Flet applications are composed of controls (widgets) that form a visual tree. Changes to this tree are efficiently rendered to the underlying UI platform (web, desktop, or mobile).</p> <p>Key aspects of Flet's usage in Lexi:</p> <ul> <li>Reactive Programming: The UI responds to state changes. When data changes, the relevant UI components are automatically updated.</li> <li>Controls: Flet provides a rich set of pre-built UI controls (e.g., <code>ft.Text</code>, <code>ft.Image</code>, <code>ft.Container</code>, <code>ft.ProgressBar</code>) that are used to construct the application's layout and interactive elements.</li> <li>Page Updates: UI changes are typically triggered by calling <code>page.update()</code>, which sends the updated control tree to the Flet client for rendering.</li> </ul>"},{"location":"guide_split/4_base64_for_images_and_animations.html","title":"4. Base64 for Images and Animations","text":"<p>Lexi utilizes Base64 encoding for embedding images and animations directly within the application's source code or configuration files. This approach is specifically evident in how the Lexi avatar (<code>avatar_base64.txt</code>) and application icon (<code>icon_base64.txt</code>) are handled. These files contain Base64 encoded strings of the respective image/GIF data.</p>"},{"location":"guide_split/4_base64_for_images_and_animations.html#41-why-base64","title":"4.1. Why Base64?","text":"<p>The decision to use Base64 for certain UI assets in Lexi, especially within a Flet application, is driven by several factors, primarily related to deployment, portability, and reduced HTTP requests in web contexts:</p> <ul> <li> <p>Self-Contained Deployment: By embedding images as Base64 strings, the application becomes more self-contained. The image data is part of the Python script or easily accessible text files, eliminating the need for separate image files that might get lost or misplaced during deployment. This simplifies distribution, especially for desktop applications, as all assets are bundled together.</p> </li> <li> <p>Reduced HTTP Requests (Web): In web-based Flet deployments, using Base64 encoded images means the browser doesn't need to make additional HTTP requests to fetch image files. The image data is already present in the HTML/CSS/JavaScript payload. For small, frequently used assets like icons and avatars, this can slightly improve initial load times by reducing network overhead. [1]</p> </li> <li> <p>Portability: Base64 encoded assets are plain text, making them highly portable across different environments and operating systems. They can be easily stored in text files, databases, or directly in code without worrying about binary file compatibility issues.</p> </li> <li> <p>Avoiding File System Access Issues: For applications packaged with tools like PyInstaller (which Lexi appears to be designed for, given the <code>sys._MEIPASS</code> handling), accessing external asset files can sometimes be problematic due to how the executable bundles resources. Embedding assets via Base64 bypasses these potential file path resolution issues at runtime.</p> </li> </ul>"},{"location":"guide_split/4_base64_for_images_and_animations.html#42-disadvantages-and-considerations","title":"4.2. Disadvantages and Considerations","text":"<p>While Base64 offers benefits, it also comes with drawbacks that are important for the UI team to understand:</p> <ul> <li> <p>Increased File Size: Base64 encoding increases the size of the original binary data by approximately 33%. [2] This means that <code>avatar_base64.txt</code> and <code>icon_base64.txt</code> are larger than their original image files. For very large images or numerous small images, this overhead can significantly increase the overall application size and memory footprint.</p> </li> <li> <p>Caching Inefficiency: Base64 encoded images are embedded directly into the HTML (or in Flet's case, sent as part of the control tree). This means they cannot be cached independently by the browser like external image files. Every time the page or component loads, the Base64 data is re-downloaded/re-processed, which can be inefficient for frequently accessed or larger assets.</p> </li> <li> <p>Maintenance Overhead: Editing or updating Base64 encoded images requires re-encoding the image and updating the corresponding text file or code. This can be a less straightforward workflow compared to simply replacing an image file.</p> </li> <li> <p>Performance for Animations: For animations (like the Lexi avatar GIF), Base64 encoding means the entire animation data is loaded at once. While convenient for bundling, for longer or more complex animations, this can consume more memory and potentially impact rendering performance compared to streaming or optimized animation formats.</p> </li> </ul>"},{"location":"guide_split/4_base64_for_images_and_animations.html#43-implementation-details-in-lexi","title":"4.3. Implementation Details in Lexi","text":"<p>In <code>Drift_mini.py</code>, you'll find code snippets similar to these for handling Base64 assets:</p> <pre><code># For the application icon\ntry:\n    with open(\"assets/icon_base64.txt\", \"r\") as f:\n        icon_base64 = f.read()\nexcept Exception as e:\n    print(\"\u26a0\ufe0f Failed to load base64 image:\", e)\n    icon_base64 = \"\"\n\nimage_control = ft.Image(\n    src=f\"data:image/png;base64,{icon_base64}\",\n    width=1200,\n    height=1200,\n    fit=ft.ImageFit.COVER\n)\n\n# For the Lexi avatar (GIF)\ntry:\n    with open(os.path.join(\n            os.path.dirname(os.path.abspath(__file__)),\n            \"assets\",\n            \"avatar_base64.txt\"\n    )) as f:\n        avatar_b64 = f.read().strip()\nexcept Exception:\n    avatar_b64 = \"\"   # fallback: blank avatar\n\navatar = ft.Container(\n    content=ft.Image(\n        src=f\"data:image/gif;base64,{avatar_b64}\",\n        width=40,\n        height=40,\n        fit=ft.ImageFit.COVER,\n        repeat=ft.ImageRepeat.NO_REPEAT,\n    ),\n)\n</code></pre> <p>As you can see, the Base64 string is read from a <code>.txt</code> file and then directly embedded into the <code>src</code> property of an <code>ft.Image</code> control using a <code>data:</code> URI scheme (<code>data:image/png;base64,...</code> or <code>data:image/gif;base64,...</code>).</p>"},{"location":"guide_split/5_ui_development_guidelines.html","title":"5. UI Development Guidelines","text":"<p>When contributing to Lexi's UI, please adhere to the following guidelines:</p>"},{"location":"guide_split/5_ui_development_guidelines.html#51-understanding-flet-controls-and-layout","title":"5.1. Understanding Flet Controls and Layout","text":"<ul> <li>Familiarize yourself with Flet documentation: Before making significant UI changes, review the official Flet documentation to understand available controls, their properties, and layout options.</li> <li>Use appropriate controls: Select Flet controls that best fit the UI element's purpose and interaction. For example, <code>ft.Container</code> for grouping and styling, <code>ft.Text</code> for static text, <code>ft.TextField</code> for input.</li> <li>Responsive Design: Design UI components to be responsive. Flet's layout system (e.g., <code>Row</code>, <code>Column</code>, <code>Container</code> with <code>expand</code> property, <code>ResponsiveRow</code>) should be used to ensure the UI adapts gracefully to different screen sizes and orientations.</li> </ul>"},{"location":"guide_split/5_ui_development_guidelines.html#52-working-with-images-and-animations","title":"5.2. Working with Images and Animations","text":"<ul> <li>Existing Base64 Assets: For the Lexi icon and avatar, continue to use the existing Base64 approach. If these assets need to be updated, convert the new image/GIF to Base64 and replace the content of <code>icon_base64.txt</code> or <code>avatar_base64.txt</code> respectively. You can use online tools or command-line utilities (e.g., <code>base64 -i image.png &gt; image_base64.txt</code>) for conversion.</li> <li>New Static Images: For any new static images that are small and integral to the application's self-contained nature (e.g., small icons, logos that are always displayed), consider converting them to Base64 and embedding them similarly. However, be mindful of the file size overhead.</li> <li>Larger Images/Dynamic Content: For larger images, user-uploaded content, or images that might change frequently, consider alternative approaches that Flet supports, such as loading images from local paths or URLs. Flet's <code>ft.Image</code> control can directly take a file path or a URL as its <code>src</code> property. This avoids the Base64 overhead for assets that don't benefit from it.</li> <li>Animations: For complex or longer animations, evaluate if GIF is the most suitable format. While Base64 embedded GIFs work for simple animations, consider optimized video formats or Lottie animations if Flet supports them in the future, especially if performance becomes an issue.</li> </ul>"},{"location":"guide_split/5_ui_development_guidelines.html#53-styling-and-theming","title":"5.3. Styling and Theming","text":"<ul> <li>Consistent Styling: Maintain a consistent visual style throughout the application. Use Flet's theming capabilities (if available and implemented) or consistently apply <code>ft.TextStyle</code> and <code>ft.Container</code> properties for colors, fonts, padding, and margins.</li> <li>Color Palette: Adhere to Lexi's defined color palette. If no formal palette exists, establish one and document it.</li> </ul>"},{"location":"guide_split/5_ui_development_guidelines.html#54-code-quality-and-maintainability","title":"5.4. Code Quality and Maintainability","text":"<ul> <li>Modularity: Break down complex UI into smaller, reusable Flet controls or functions. This improves readability and maintainability.</li> <li>Clear Naming Conventions: Use descriptive names for variables, functions, and controls.</li> <li>Comments: Add comments where necessary to explain complex logic or non-obvious UI decisions.</li> <li>Error Handling: Implement robust error handling for UI operations, especially when dealing with external resources or user input.</li> <li>Performance: Be mindful of UI performance. Avoid unnecessary <code>page.update()</code> calls and optimize complex layouts.</li> </ul>"},{"location":"guide_split/6_contribution_workflow.html","title":"6. Contribution Workflow","text":"<ol> <li>Branching: Create a new branch for your UI changes (e.g., <code>feature/new-chat-ui</code>, <code>fix/avatar-display</code>).</li> <li>Development: Implement your UI changes, following the guidelines above.</li> <li>Testing: Thoroughly test your changes across different screen sizes and interactions.</li> <li>Code Review: Submit a pull request for review by another team member.</li> <li>Deployment: Once approved, merge your changes to the main branch.</li> </ol>"},{"location":"guide_split/7_resources.html","title":"7. Resources","text":"<ul> <li>Flet Documentation</li> <li>Flet GitHub Repository</li> </ul>"},{"location":"guide_split/8_detailed_ui_elements_and_functionality.html","title":"8. Detailed UI Elements and Functionality","text":"<p>Lexi's user interface is designed to be intuitive and functional, guiding the user through model interaction, PDF processing, and conversational AI. This section details the key UI components, their purpose, and relevant code snippets.</p>"},{"location":"guide_split/8_detailed_ui_elements_and_functionality.html#81-initial-loading-and-download-screen","title":"8.1. Initial Loading and Download Screen","text":"<p>Upon launching Lexi, the application first checks for and downloads necessary AI models. This process is represented by a dynamic loading screen, ensuring the user is aware of the background operations.</p> <p>Purpose: To provide visual feedback during the initial setup, model download, and loading phases, preventing the application from appearing unresponsive. It also informs the user about the progress of large file downloads.</p> <p>Key Components &amp; Functionality:</p> <ul> <li> <p>Progress Bar (<code>ft.ProgressBar</code>): Displays the overall download and loading progress. The <code>HfProgress</code> class customizes this to show Hugging Face model download progress.     <pre><code># Snippet from HfProgress class in Drift_mini.py\nclass HfProgress(tqdm):\n    # ... (init and other methods)\n    def display(self, msg=None, pos=None):\n        # Calculate percentage\n        if self.total and self.n is not None and self.total &gt; 0:\n            percentage = 100.0 * self.n / self.total\n        else:\n            percentage = 0.0\n\n        # Construct status message\n        if self.n is not None and self.total is not None:\n            status_msg = f\"Downloading: {self.n / 1024 / 1024:.1f}MB / {self.total / 1024 / 1024:.1f}MB ({percentage:.1f}%)\"\n        else:\n            status_msg = \"Downloading: calculating size...\"\n\n        # Update UI\n        if hasattr(self, 'screen') and self.screen and not self.screen.is_cancelled and self.screen.active:\n            try:\n                self.screen.update_progress(\n                    40 + (percentage * 0.6),  # Scale to 40-100% range (embedding is first 40%)\n                    status_msg\n                )\n            except Exception as e:\n                print(f\"Error updating progress UI: {e}\")\n        # ...\n</code></pre></p> </li> <li> <p>Status Text (<code>ft.Text</code>): Provides textual updates on the current operation (e.g., \"Initializing...\", \"Downloading models...\", \"Loading LLM...\").     <pre><code>    # Snippet from main function in Drift_mini.py\n    status_text = ft.Text(\"Initializing...\", size=16, color=\"white\")\n    # ...\n    page.add(ft.Container(\n        content=ft.Column([\n            ft.Image(\n                src=f\"data:image/png;base64,{icon_base64}\",\n                width=1200,\n                height=1200,\n                fit=ft.ImageFit.COVER\n            ),\n            ft.Container(height=16),\n            status_text,\n            ft.Container(height=16),\n            progress_bar\n        ]),\n        alignment=ft.alignment.center,\n        expand=True\n    ))\n</code></pre></p> </li> <li> <p>Error Messages: If model download or initialization fails, a clear error message is displayed to the user.         <pre><code># Snippet from main function in Drift_mini.py\nif not success:\n    page.add(ft.Container(\n        content=ft.Text(\"\u274c Model download failed. Please check your connection.\", color=\"white\"),\n        alignment=ft.alignment.center,\n        expand=True\n    ))\n    page.update()\n    return\n# ...\nif not success:\n    page.add(ft.Container(\n        content=ft.Text(\"\u274c Failed to initialize. Check models or logs.\", color=\"white\"),\n        alignment=ft.alignment.center,\n        expand=True\n    ))\n    page.update()\n    return\n</code></pre></p> </li> </ul>"},{"location":"guide_split/8_detailed_ui_elements_and_functionality.html#82-main-chat-interface","title":"8.2. Main Chat Interface","text":"<p>Once initialized, the user is presented with the main chat interface, which facilitates interaction with the Lexi AI.</p> <p>Key Components &amp; Functionality:</p> <ul> <li> <p>App Bar (<code>ft.AppBar</code> or <code>ft.Container</code> acting as one): Located at the top, it contains the application title, status indicators, and action buttons.</p> <ul> <li>Lexi Icon and Title: Displays the Lexi logo (Base64 encoded) and the application name.</li> <li>Model Status Indicator (<code>ft.Text</code>): Shows which model is currently loaded (e.g., \"Optimal Model Selected\").</li> <li>Model Selection Button (<code>ft.IconButton</code>): Triggers a dialog for the user to select a different AI model.     <pre><code># Snippet from app_bar creation in Drift_mini.py\napp_bar = ft.Container(\n    content=ft.Row([\n        ft.IconButton(\n            icon=ft.icons.MENU,\n            icon_color=\"#FFFFFF\",\n            on_click=lambda e: page.go(\"/settings\"), # Example navigation\n        ),\n        ft.Container(width=12),\n        ft.Column([\n            ft.Text(\n                \"Lexi Drift\",\n                color=\"#FFFFFF\",\n                size=20,\n                weight=ft.FontWeight.BOLD,\n            ),\n            ft.Text(\n                \"Optimal Model Selected\", # This text changes based on model status\n                color=\"#BDBDBD\",\n                size=12,\n            ),\n        ]),\n        ft.Container(expand=True), \n        ft.TextButton(\n            content=ft.Row([\n                ft.Icon(ft.icons.SETTINGS, color=\"#FFFFFF\"),\n                ft.Text(\"Models\", color=\"#FFFFFF\"),\n            ]),\n            on_click=lambda e: open_model_dialog(),\n        ),\n        ft.IconButton(\n            icon=ft.icons.INFO_OUTLINE,\n            icon_color=\"#FFFFFF\",\n            on_click=lambda e: open_info_dialog(),\n        ),\n        ft.IconButton(\n            icon=ft.icons.FILE_UPLOAD,\n            icon_color=\"#FFFFFF\",\n            on_click=lambda e: file_picker.pick_files(allow_multiple=True),\n        ),\n    ]),\n    padding=ft.padding.only(left=10, right=10, top=5, bottom=5),\n    bgcolor=\"#202020\",\n    width=page.width,\n)\n</code></pre></li> <li>Info Button (<code>ft.IconButton</code>): Displays information about the application or current model.</li> <li>File Upload Button (<code>ft.IconButton</code>): Initiates the file picker to allow users to upload documents (e.g., PDFs) for processing.     <pre><code># Snippet from file picker setup in Drift_mini.py\nfile_picker = ft.FilePicker(\n    on_result=lambda e: on_file_picked(e, page, chat_column, input_field, send_button, typing_indicator, info_card)\n)\npage.overlay.append(file_picker)\n</code></pre></li> </ul> </li> <li> <p>Chat History Area (<code>ft.Column</code>): This is the main display area where conversational turns (user queries and Lexi's responses) are rendered.</p> <ul> <li>User Messages: Displayed with a distinct background and alignment (e.g., right-aligned).</li> <li>Lexi Messages: Displayed with a distinct background and alignment (e.g., left-aligned), often accompanied by the Lexi avatar.</li> <li>Code Highlighting: Lexi can generate code, which is then highlighted using Pygments for readability.     <pre><code># Snippet from message rendering in Drift_mini.py\n# ... inside a function that adds messages to chat_column\nif is_user:\n    bubble = ft.Container(\n        content=ft.Text(message, color=\"#FFFFFF\"),\n        bgcolor=\"#4A4A4A\",\n        border_radius=10,\n        padding=10,\n    )\n    msg_widget = ft.Row([ft.Container(expand=True), bubble], alignment=ft.MainAxisAlignment.END)\nelse:\n    # ... Lexi avatar logic ...\n    if message.startswith(\"```\") and message.endswith(\"```\"):\n        # Code block, apply highlighting\n        lang_match = re.match(r\"```(\\w+)?\\n\", message)\n        lang = lang_match.group(1) if lang_match else \"text\"\n        code_content = message[lang_match.end():-3].strip()\n        highlighted_spans = highlight_code_multilang(code_content, lang)\n        bubble_content = ft.Column([\n            ft.Text(\"Lexi:\", color=\"#FFFFFF\", weight=ft.FontWeight.BOLD),\n            ft.Container(height=5),\n            ft.Column(highlighted_spans, spacing=0)\n        ])\n    else:\n        bubble_content = ft.Text(message, color=\"#FFFFFF\")\n\n    bubble = ft.Container(\n        content=bubble_content,\n        bgcolor=\"#333333\",\n        border_radius=10,\n        padding=10,\n    )\n    msg_widget = ft.Row([avatar, bubble], alignment=ft.MainAxisAlignment.START)\nchat_column.controls.append(msg_widget)\npage.update()\n</code></pre></li> </ul> </li> <li> <p>Typing Indicator (<code>ft.Container</code> with <code>ft.Text</code>): Appears when Lexi is generating a response, providing visual cues that the AI is processing.     <pre><code># Snippet from typing indicator in Drift_mini.py\ntyping_indicator = ft.Container(\n    content=ft.Row([\n        ft.ProgressRing(width=16, height=16, stroke_width=2),\n        ft.Text(\"Lexi is typing...\", color=\"#BDBDBD\"),\n    ]),\n    visible=False, # Initially hidden\n)\n</code></pre></p> </li> <li> <p>PDF Processing Indicator: When a PDF is uploaded and processed, a message indicates the status (e.g., \"Processing PDF...\").</p> </li> </ul>"},{"location":"guide_split/8_detailed_ui_elements_and_functionality.html#83-input-area","title":"8.3. Input Area","text":"<p>At the bottom of the main chat interface, the input area allows users to type their queries and send them to Lexi.</p> <p>Key Components &amp; Functionality:</p> <ul> <li> <p>Text Input Field (<code>ft.TextField</code>): Where the user types their message. It supports multiline input and has a hint text.     <pre><code># Snippet from input_field creation in Drift_mini.py\ninput_field = ft.TextField(\n    hint_text=\"Type your message...\",\n    hint_style=ft.TextStyle(color=\"#BDBDBD\"),\n    multiline=True,\n    min_lines=1,\n    max_lines=5,\n    expand=True,\n    border_radius=15,\n    filled=True,\n    bgcolor=\"#333333\",\n    border_color=\"#4A4A4A\",\n    text_style=ft.TextStyle(color=\"#FFFFFF\"),\n    on_submit=lambda e: send_message(e, page, chat_column, input_field, send_button, typing_indicator, info_card),\n)\n</code></pre></p> </li> <li> <p>Send Button (<code>ft.IconButton</code>): Sends the message typed in the input field to Lexi. It is typically enabled when there is text in the input field.     <pre><code># Snippet from send_button creation in Drift_mini.py\nsend_button = ft.IconButton(\n    icon=ft.icons.SEND,\n    icon_color=\"#FFFFFF\",\n    on_click=lambda e: send_message(e, page, chat_column, input_field, send_button, typing_indicator, info_card),\n    disabled=True, # Initially disabled\n)\n</code></pre></p> </li> </ul>"},{"location":"guide_split/8_detailed_ui_elements_and_functionality.html#84-model-selection-dialog","title":"8.4. Model Selection Dialog","text":"<p>This dialog allows users to switch between different AI models available in Lexi. It's typically triggered by a button in the app bar.</p> <p>Key Components &amp; Functionality:</p> <ul> <li>Dialog (<code>ft.AlertDialog</code>): A modal overlay that presents model options.</li> <li>Model List (<code>ft.Column</code> of <code>ft.Row</code>s): Each row represents a model, showing its name, description, and a button to select it.     <pre><code># Snippet from open_model_dialog function in Drift_mini.py\ndef open_model_dialog():\n    model_options = [\n        (\"Lexi Lite\", \"Smaller, faster model for quick responses.\", \"phi-1_5-gguf-4bit\"),\n        (\"Lexi Core\", \"Balanced model for general tasks.\", \"phi-2-gguf-4bit\"),\n        (\"Lexi Edge\", \"Advanced model for complex queries.\", \"phi-3-mini-4k-instruct\"),\n        (\"Lexi Ultra\", \"Largest model for maximum capability.\", \"deepseek-llm-7b-chat-gguf-q4\")\n    ]\n\n    model_controls = []\n    for name, description, model_folder in model_options:\n        model_controls.append(\n            ft.Row([\n                ft.Column([\n                    ft.Text(name, weight=ft.FontWeight.W_500, size=14),\n                    ft.Text(description, size=12, color=\"#BDBDBD\"),\n                ]),\n                ft.Container(expand=True),\n                ft.TextButton(\n                    \"Select\",\n                    on_click=partial(select_model, model_folder, name),\n                ),\n            ])\n        )\n\n    dialog = ft.AlertDialog(\n        modal=True,\n        title=ft.Text(\"Available Models\"),\n        content=ft.Column(\n            model_controls,\n            scroll=\"always\",\n            height=300,\n        ),\n        actions=[\n            ft.TextButton(\"Close\", on_click=lambda _: close_dialog()),\n        ],\n        actions_alignment=ft.MainAxisAlignment.END,\n    )\n    page.dialog = dialog\n    dialog.open = True\n    page.update()\n</code></pre></li> <li>Disclaimer: Warns users about potential crashes when switching models.</li> <li>Close Button: Closes the dialog.</li> </ul>"},{"location":"guide_split/8_detailed_ui_elements_and_functionality.html#85-information-dialog","title":"8.5. Information Dialog","text":"<p>This dialog provides general information about Lexi, potentially including version details, credits, or links to documentation.</p> <p>Key Components &amp; Functionality:</p> <ul> <li>Dialog (<code>ft.AlertDialog</code>): A modal overlay for displaying information.</li> <li>Content (<code>ft.Text</code>): Displays the informational text.</li> <li>Close Button: Closes the dialog.</li> </ul>"},{"location":"guide_split/8_detailed_ui_elements_and_functionality.html#86-pdf-upload-and-processing","title":"8.6. PDF Upload and Processing","text":"<p>Lexi allows users to upload PDF documents, which are then processed to extract text and create embeddings for conversational context.</p> <p>Key Components &amp; Functionality:</p> <ul> <li>File Picker (<code>ft.FilePicker</code>): A non-visual control that interacts with the operating system to allow users to select files. Its <code>on_result</code> event handler processes the selected files.     <pre><code># Snippet from on_file_picked function in Drift_mini.py\nasync def on_file_picked(e: ft.FilePickerResultEvent, page, chat_column, input_field, send_button, typing_indicator, info_card):\n    if e.files:\n        for file in e.files:\n            # Display message that PDF is being processed\n            add_message(page, chat_column, f\"Processing PDF: {file.name}...\", is_user=True)\n            page.update()\n\n            # Simulate processing time or actual processing\n            await asyncio.sleep(1) \n\n            # Actual PDF processing logic (simplified for snippet)\n            pdf_path = file.path\n            if pdf_path:\n                # ... (PDF loading, splitting, embedding logic)\n                add_message(page, chat_column, f\"PDF '{file.name}' processed and ready for questions!\", is_user=False)\n            else:\n                add_message(page, chat_column, f\"Failed to load PDF '{file.name}'.\", is_user=False)\n            page.update()\n</code></pre></li> <li>Status Messages in Chat: Messages are added to the chat history to inform the user about the PDF processing status (e.g., \"Processing PDF: ...\", \"PDF processed...\").</li> </ul> <p>When making changes or adding new features, always consider the existing structure and design principles.</p>"},{"location":"guide_split/9_data_handling_and_lexi_driftpdf.html","title":"9. Data Handling and <code>lexi_drift.pdf</code>","text":"<p>Lexi leverages various data sources to provide comprehensive and contextually relevant responses. A crucial component of this data handling is the <code>lexi_drift.pdf</code> file.</p>"},{"location":"guide_split/9_data_handling_and_lexi_driftpdf.html#91-purpose-of-lexi_driftpdf","title":"9.1. Purpose of <code>lexi_drift.pdf</code>","text":"<p><code>lexi_drift.pdf</code> serves as a foundational knowledge base for Lexi, particularly for generating initial greetings and general conversational responses. When the application launches, this PDF is automatically loaded and its content is used to prime Lexi's understanding. This allows Lexi to provide consistent and pre-defined responses to common scenarios or initial user interactions without relying solely on its large language model for every basic query.</p> <p>Key Roles:</p> <ul> <li>Default Greetings and General Responses: It contains pre-authored text that guides Lexi's initial interactions, ensuring a friendly and consistent user experience from the start.</li> <li>Scenario-Based Interactions: The design allows for the inclusion of responses to specific, pre-defined scenarios. By adding relevant information or conversational flows into <code>lexi_drift.pdf</code>, Lexi can provide tailored and accurate answers for particular situations, acting as a form of 'programmed' knowledge.</li> </ul>"},{"location":"guide_split/9_data_handling_and_lexi_driftpdf.html#92-how-lexi_driftpdf-is-used","title":"9.2. How <code>lexi_drift.pdf</code> is Used","text":"<p>When Lexi starts, the <code>Drift_mini.py</code> script identifies and processes <code>lexi_drift.pdf</code>. The content of this PDF is then converted into a format that the AI model can utilize for retrieval-augmented generation. This typically involves:</p> <ol> <li>Loading: The <code>PyPDFLoader</code> (from <code>langchain_community.document_loaders</code>) is used to read the text content from <code>lexi_drift.pdf</code>.</li> <li>Text Splitting: The extracted text is broken down into smaller, manageable chunks using a <code>RecursiveCharacterTextSplitter</code>. This is crucial for efficient processing and retrieval by the language model.</li> <li>Embedding: Each text chunk is then converted into numerical vector representations (embeddings) using a <code>SentenceTransformer</code> model (e.g., <code>all-MiniLM-L6-v2</code>). These embeddings capture the semantic meaning of the text.</li> <li>Vector Store: The embeddings are stored in a <code>Chroma</code> vector database. This database allows for fast and efficient similarity searches, enabling Lexi to quickly find relevant information from the PDF based on user queries.</li> <li>Conversational Retrieval Chain: A <code>ConversationalRetrievalChain</code> (from <code>langchain.chains</code>) is established. This chain uses the vector store to retrieve relevant document chunks from <code>lexi_drift.pdf</code> based on the current conversation history and user input. The retrieved information is then provided to the main language model as context, allowing it to generate more informed and accurate responses.</li> </ol> <p>Code Snippet for PDF Processing (Conceptual Flow):</p> <pre><code># Snippet from main function or a dedicated PDF processing function in Drift_mini.py\n# ... (imports and setup)\n\nTEMP_PDF = \"./lexi_drift\" # This likely refers to the directory where the PDF is expected or processed\n\nasync def process_pdf_for_rag(pdf_path: str, embeddings_model, vector_store_instance):\n    try:\n        loader = PyPDFLoader(pdf_path)\n        documents = loader.load()\n\n        text_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=1000,\n            chunk_overlap=200\n        )\n        texts = text_splitter.split_documents(documents)\n\n        # Create or update vector store with PDF content\n        # This is a simplified representation; actual implementation might differ\n        vector_store_instance = Chroma.from_documents(texts, embeddings_model)\n\n        print(f\"Successfully processed PDF: {pdf_path}\")\n        return vector_store_instance\n\n    except Exception as e:\n        print(f\"Error processing PDF {pdf_path}: {e}\")\n        return None\n\n# ... (later in main or initialization logic)\n# Assuming 'embeddings' is an initialized HuggingFaceEmbeddings instance\n# and 'vector_db' is a global or passed Chroma instance\n# await process_pdf_for_rag(os.path.join(TEMP_PDF, \"lexi_drift.pdf\"), embeddings, vector_db)\n</code></pre>"},{"location":"guide_split/9_data_handling_and_lexi_driftpdf.html#93-maintaining-and-extending-lexi_driftpdf","title":"9.3. Maintaining and Extending <code>lexi_drift.pdf</code>","text":"<p>For the UI team, understanding <code>lexi_drift.pdf</code> is important for several reasons:</p> <ul> <li>Content Updates: If Lexi's default greetings or responses to specific scenarios need to be updated, the <code>lexi_drift.pdf</code> file is the primary place to make these changes. After updating the PDF, it must be re-processed by the application to reflect the new knowledge.</li> <li>Scenario Expansion: To enable Lexi to handle new, pre-defined conversational scenarios, relevant information can be added to <code>lexi_drift.pdf</code>. This allows for a controlled expansion of Lexi's knowledge base for specific use cases without requiring a full model retraining.</li> <li>Debugging and Testing: When Lexi provides unexpected or incorrect general responses, checking the content of <code>lexi_drift.pdf</code> should be one of the first debugging steps. Ensuring the PDF contains accurate and well-structured information is key to Lexi's performance in these areas.</li> </ul> <p>It is recommended to maintain <code>lexi_drift.pdf</code> with clear, concise, and well-organized text to maximize its effectiveness in guiding Lexi's responses. Avoid overly complex formatting within the PDF, as the primary goal is text extraction for semantic understanding.</p>"}]}